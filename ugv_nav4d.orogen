name "ugv_nav4d"

using_library "ugv_nav4d"
using_library "trajectory_follower"
using_library "base-lib"
using_library "orocos_cpp"

import_types_from "base"
import_types_from "envire_maps"

import_types_from "ugv_nav4d/TraversabilityConfig.hpp"
import_types_from "ugv_nav4d/Mobility.hpp"

import_types_from "ugv_nav4d/PreComputedMotions.hpp"

import_types_from "sbpl_spline_primitives/SplinePrimitivesConfig.hpp"

using_library "vizkit3d_debug_drawings"
import_types_from "vizkit3d_debug_drawings"


import_types_from "trajectory_follower/SubTrajectory.hpp"

task_context "PathPlanner" do
    needs_configuration

    # --- Properties ---

    property "maxTime", "base::Time"
    property "primConfig", "sbpl_spline_primitives::SplinePrimitivesConfig"
    property "travConfig", "ugv_nav4d::TraversabilityConfig"
    property "mobilityConfig", "ugv_nav4d::Mobility"
    property "plannerConfig", "ugv_nav4d::PlannerConfig"
    property("initialPatchRadius","double", 0.0)
    property("dumpOnError","int", 0)
    property("dumpOnSuccess","int", 0)

    # --- Input ports ---

    input_port "map", spatio_temporal('/maps/grid/MLSMapKalman')
    input_port "start_pose_samples", "base/samples/RigidBodyState"  # should be travConfig.distToGround above the floor

    # Writing in one of those ports triggers the path planning, if map and start_pose_samples are given.
    input_port "goal_pose_relative", "base/samples/RigidBodyState"  # should be travConfig.distToGround above the floor
    input_port "goal_pose_absolute", "base/samples/RigidBodyState"   # should be travConfig.distToGround above the floor

    # --- Output ports ---

    output_port "trajectory2D", "std::vector<base/Trajectory>"
    output_port "trajectory3D", "std::vector<base/Trajectory>"
    output_port "detailedTrajectory2D", "std::vector<trajectory_follower/SubTrajectory>"
    output_port "detailedTrajectory3D", "std::vector<trajectory_follower/SubTrajectory>"

    output_port "tr_map", spatio_temporal('/maps/grid/TraversabilityBaseMap3d')

    output_port "planning_start", "base/samples/RigidBodyState"
    output_port "planning_goal", "base/samples/RigidBodyState"

    dynamic_output_port /^debug_ugv_nav4d/, "/boost/shared_ptr</vizkit3dDebugDrawings/CommandBuffer>"

    # --- Operations ---

    operation("triggerPathPlanning").
        arg("start_position", "base/samples/RigidBodyState"). # should be travConfig.distToGround above the floor
        arg("goal_position", "base/samples/RigidBodyState"). # should be travConfig.distToGround above the floor
        returns("int").
        doc("Triggers planning of a new path")

    operation("generateTravMap").
        returns("int").
        doc("Triggers generation of the traversability map")

    runtime_states :NO_MAP,
        :SET_UP_MAP_AND_SPLINES,
        :GOT_MAP,
        :GOAL_INVALID,
        :START_INVALID,
        :INTERNAL_ERROR,
        :PLANNING,
        :TRAVERSABILITY_MAP_GENERATED,
        :NO_SOLUTION,
        :FOUND_SOLUTION


    periodic 0.1
end

# Loads a pointcloud from a ply file and generates a MLS from it.
# (For testing or if you want to use a static map)
task_context "MapLoader" do

	output_port('map', spatio_temporal('maps/grid/MLSMapKalman'))
	.doc("Generated MLS map, request via publishMap operation.")

	property('path', 'std/string')
	.doc("File location of the PLY to load.")

	property('resolution', 'double', 0.1)
	.doc("Cell size of the generated MLS map.")

	property('mls_config', 'maps/grid/MLSConfig')
	.doc("Parameters of the generated MLS map.")

	property('map_frame', 'std/string', "static_map")
	.doc("Envire frame the map will be attached to.")

	operation('publishMap')
	.doc("Writes the map to the port.")

	periodic(1.0)
end
